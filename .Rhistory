library(boot)
boot::inv.logit
dbinom(c(dat1$yCT,dat1$yCC),1,m1)
dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m1))
m1
dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m1))
dbinom(dat2$yEC,            1,boot::inv.logit(m2))
dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m3))
dbinom(dat2$yEC,            1,boot::inv.logit(m4))
w[ss,s1,s2] <- (   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m1))))
+a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m2))))
-   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m3))))
-a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m4)))))
w[ss,s1,s2]
mcmc3.sample$theta
mcmc4.sample$theta
mean(mcmc3.sample$theta>0)
mean(mcmc4.sample$theta>0)
mcmc3.sample$theta
n.CT2 <- n.CT-n.CT1
n.CC2 <- n.CC-n.CC1
ncov  <- length(cov.CT)
ls1 <- length(out.prob.EC)
ls2 <- length(out.prob.CT)
w  <- array(0,dim=c(nsim,ls1,ls2))
p1 <- array(0,dim=c(nsim,ls1,ls2))
p2 <- array(0,dim=c(nsim,ls1,ls2))
for(ss in 1:nsim){
for(s1 in 1:ls1){
for(s2 in 1:ls2){
marg.CT <- list(list(dist="binom",parm=list(size=1,prob=out.prob.CT[s2])))
marg.CC <- list(list(dist="binom",parm=list(size=1,prob=out.prob.CC)))
marg.EC <- list(list(dist="binom",parm=list(size=1,prob=out.prob.EC[s1])))
for(i in 1:ncov){
if(cov.CT[[i]]$dist=="norm"){
marg.CT <- append(marg.CT,list(list(dist=cov.CT[[i]]$dist,parm=list(mean=cov.CT[[i]]$mean,sd=cov.CT[[i]]$sd))))
marg.CC <- append(marg.CC,list(list(dist=cov.CC[[i]]$dist,parm=list(mean=cov.CC[[i]]$mean,sd=cov.CC[[i]]$sd))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(mean=cov.EC[[i]]$mean,sd=cov.EC[[i]]$sd))))
}else if(cov.CT[[i]]$dist=="binom"){
marg.CT <- append(marg.CT,list(list(dist=cov.CT[[i]]$dist,parm=list(size=1,prob=cov.CT[[i]]$prob))))
marg.CC <- append(marg.CC,list(list(dist=cov.CC[[i]]$dist,parm=list(size=1,prob=cov.CC[[i]]$prob))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(size=1,prob=cov.EC[[i]]$prob))))
}
}
cvec <- cormat[lower.tri(cormat)]
data.CT1 <- datagen(margdist=marg.CT,corvec=cvec,nsim=n.CT1)
data.CC1 <- datagen(margdist=marg.CC,corvec=cvec,nsim=n.CC1)
data.CT2 <- datagen(margdist=marg.CT,corvec=cvec,nsim=n.CT2)
data.CC2 <- datagen(margdist=marg.CC,corvec=cvec,nsim=n.CC2)
data.CT <- rbind(data.CT1,data.CT2)
data.CC <- rbind(data.CC1,data.CC2)
data.EC <- datagen(margdist=marg.EC,corvec=cvec,nsim=n.EC)
dat1 <- list(
nCT = n.CT1,
nCC = n.CC1,
p   = ncov,
yCT = data.CT1[,1],
yCC = data.CC1[,1],
xCT = data.CT1[,-1],
xCC = data.CC1[,-1])
dat2 <- list(
nEC = n.EC,
p   = ncov,
yEC = data.EC[,1],
xEC = data.EC[,-1],
a0  = a0)
dat3 <- list(
nCT = n.CT1,
nCC = n.CC1,
nEC = n.EC,
p   = ncov,
yCT = data.CT1[,1],
yCC = data.CC1[,1],
yEC = data.EC[,1],
xCT = data.CT1[,-1],
xCC = data.CC1[,-1],
xEC = data.EC[,-1],
a0  = a0)
dat4 <- list(
nCT = n.CT,
nCC = n.CC,
p   = ncov,
yCT = data.CT[,1],
yCC = data.CC[,1],
xCT = data.CT[,-1],
xCC = data.CC[,-1])
mcmc1 <- rstan::sampling(norm.reg1,dat1,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc1.sample <- rstan::extract(mcmc1)
mcmc2 <- rstan::sampling(norm.reg2,dat2,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc2.sample <- rstan::extract(mcmc2)
mcmc3 <- rstan::sampling(norm.reg3,dat3,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc3.sample <- rstan::extract(mcmc3)
mcmc4 <- rstan::sampling(norm.reg1,dat4,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc4.sample <- rstan::extract(mcmc4)
hat.gammaCC0 <- median(mcmc2.sample$gammaCC)
hat.beta0    <- apply(mcmc2.sample$beta,2,median)
hat.gammaCC1 <- median(mcmc1.sample$gammaCC)
hat.theta1   <- median(mcmc1.sample$theta)
hat.beta1    <- apply(mcmc1.sample$beta,2,median)
hat.gammaCC <- median(mcmc3.sample$gammaCC)
hat.theta   <- median(mcmc3.sample$theta)
hat.beta    <- apply(mcmc3.sample$beta,2,median)
m1.CT <- hat.gammaCC1+hat.theta1+(dat1$xCT)%*%hat.beta1
m1.CC <- hat.gammaCC1           +(dat1$xCC)%*%hat.beta1
m1    <- rbind(m1.CT,m1.CC)
m2    <- hat.gammaCC0           +(dat2$xEC)%*%hat.beta0
m3.CT <- hat.gammaCC +hat.theta +(dat1$xCT)%*%hat.beta
m3.CC <- hat.gammaCC            +(dat1$xCC)%*%hat.beta
m3    <- rbind(m3.CT,m3.CC)
m4    <- hat.gammaCC            +(dat2$xEC)%*%hat.beta
w[ss,s1,s2] <- (   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m1))))
+a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m2))))
-   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m3))))
-a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m4)))))
if(alternative=="greater"){
p1[ss,s1,s2] <- mean(mcmc3.sample$theta>0)
p2[ss,s1,s2] <- mean(mcmc4.sample$theta>0)
}else if(alternative=="less"){
p1[ss,s1,s2] <- mean(mcmc3.sample$theta<0)
p2[ss,s1,s2] <- mean(mcmc4.sample$theta<0)
}
}}}
r1 <- (p1>(1-sig.level))
r2 <- (p2>(1-sig.level))
lw        <- length(w0)
sig.rate  <- array(0,dim=c(2,lw,ls1))
max.t1e   <- numeric(lw)
min.pow   <- numeric(lw)
stop.rate <- array(0,dim=c(2,lw,ls1))
for(i in 1:lw){
sig.rate[1,i,]  <- apply(r1[,,1]*(w[,,1]<=w0[i])+r2[,,1]*(w[,,1]>w0[i]),2,mean)
sig.rate[2,i,]  <- apply(r1[,,2]*(w[,,2]<=w0[i])+r2[,,2]*(w[,,2]>w0[i]),2,mean)
max.t1e[i]      <- max(sig.rate[1,i,])
min.pow[i]      <- min(sig.rate[2,i,])
stop.rate[1,i,] <- apply(w[,,1]<=w0[i],2,mean)
stop.rate[2,i,] <- apply(w[,,2]<=w0[i],2,mean)
}
w0.opt <- max(w0[(max.t1e<=accept.t1e)&(min.pow>=accept.pow)])
w0.flg <- which(w0==w0.opt)
t1e           <- sig.rate[1,w0.flg,]
stop.null     <- apply(w[,,1]<=w0.opt,2,mean)
exp.size.null <- stop.null*(n.CT1+n.CC1)+(1-stop.null)*(n.CT+n.CC)
pow           <- sig.rate[2,w0.flg,]
stop.alt      <- apply(w[,,2]<=w0.opt,2,mean)
exp.size.alt  <- stop.alt*(n.CT1+n.CC1)+(1-stop.alt)*(n.CT+n.CC)
list(w=w,p1=p1,p2=p2,
sig.rate=sig.rate,max.t1e=max.t1e,min.pow=min.pow,
stop.rate=stop.rate,w0.opt=w0.opt,t1e=t1e,stop.null=stop.null,
exp.size.null=exp.size.null,pow=pow,stop.alt=stop.alt,
exp.size.alt=exp.size.alt)
tempdir()
library(iaborrow)
library(iaborrow)
library(iaborrow)
11
logistic.reg1 <- stan.bin.concurrent()
stan.bin.concurrent <- function()
{
stanmodel <-
'
data {
int<lower=1> nCT;
int<lower=1> nCC;
int<lower=1> p;
int<lower=0,upper=1> yCT[nCT];
int<lower=0,upper=1> yCC[nCC];
row_vector[p] xCT[nCT];
row_vector[p] xCC[nCC];
}
parameters {
real gammaCC;
vector[p] beta;
real theta;
}
model {
for (i in 1:nCT)
target += bernoulli_lpmf(yCT[i]|inv_logit(gammaCC+theta+xCT[i]*beta));
for (i in 1:nCC)
target += bernoulli_lpmf(yCC[i]|inv_logit(gammaCC      +xCC[i]*beta));
}
'
return(rstan::stan_model(model_code=stanmodel))
}
stan.bin.external <- function()
{
stanmodel <-
'
data {
int<lower=1> nEC;
int<lower=1> p;
int<lower=0,upper=1> yEC[nEC];
row_vector[p] xEC[nEC];
real a0;
}
parameters {
real gammaCC;
vector[p] beta;
}
model {
for (i in 1:nEC)
target += a0*bernoulli_lpmf(yEC[i]|inv_logit(gammaCC+xEC[i]*beta));
}
'
return(rstan::stan_model(model_code=stanmodel))
}
stan.bin.hybrid <- function()
{
stanmodel <-
'
data {
int<lower=1> nCT;
int<lower=1> nCC;
int<lower=1> nEC;
int<lower=1> p;
int<lower=0,upper=1> yCT[nCT];
int<lower=0,upper=1> yCC[nCC];
int<lower=0,upper=1> yEC[nEC];
row_vector[p] xCT[nCT];
row_vector[p] xCC[nCC];
row_vector[p] xEC[nEC];
real a0;
}
parameters {
real gammaCC;
vector[p] beta;
real theta;
}
model {
for (i in 1:nCT)
target +=    bernoulli_lpmf(yCT[i]|inv_logit(gammaCC+theta+xCT[i]*beta));
for (i in 1:nCC)
target +=    bernoulli_lpmf(yCC[i]|inv_logit(gammaCC      +xCC[i]*beta));
for (i in 1:nEC)
target += a0*bernoulli_lpmf(yEC[i]|inv_logit(gammaCC      +xEC[i]*beta));
}
'
return(rstan::stan_model(model_code=stanmodel))
}
datagen <- function(margdist,corvec,nsim)
{
varnum <- length(margdist)
cormat <- copula::normalCopula(param=corvec,dim=varnum,dispstr="un")
dist <- NULL
parm <- NULL
for(i in 1:varnum){
dist <- c(dist,(margdist[[i]])$dist)
parm <- append(parm,list((margdist[[i]])$parm))
}
mycop <- copula::mvdc(copula=cormat,margins=dist,paramMargins=parm)
return(copula::rMvdc(nsim,mycop))
}
logistic.reg1 <- stan.bin.concurrent()
logistic.reg2 <- stan.bin.external()
logistic.reg3 <- stan.bin.hybrid()
n.CT2 <- n.CT-n.CT1
ncore=2
n.CT  <- 180
n.CC  <- 180
n.EC  <- 200
n.CT1 <- 90
n.CC1 <- 90
out.prob.CT <- c(0.23,0.35)
out.prob.CC <- 0.23
driftOR     <- c(0.6,1.0,1.4)
cov.CT <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cov.CC <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cov.EC <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cormat <- rbind(c(1.0,0.1,0.2,0.3),
c(0.1,1.0,0.4,0.5),
c(0.2,0.4,1.0,0.6),
c(0.3,0.5,0.6,1.0))
a0 <- 0.5
w0 <- seq(0,5,0.1)
chains=2
iter=4000
warmup=floor(iter/2)
thin=1
sig.level=0.05
alternative="greater"
accept.t1e=0.1
accept.pow=0.7
nsim=10
ncore=2
n.CT2 <- n.CT-n.CT1
n.CC2 <- n.CC-n.CC1
ncov  <- length(cov.CT)
out.prob.EC <- (driftOR*out.prob.CC/(1-out.prob.CC))/(1+driftOR*out.prob.CC/(1-out.prob.CC))
ls1 <- length(out.prob.EC)
ls2 <- length(out.prob.CT)
simulation <- function()
{
w  <- array(0,dim=c(nsim/ncore,ls1,ls2))
p1 <- array(0,dim=c(nsim/ncore,ls1,ls2))
p2 <- array(0,dim=c(nsim/ncore,ls1,ls2))
for(ss in 1:(nsim/ncore)){
for(s1 in 1:ls1){
for(s2 in 1:ls2){
marg.CT <- list(list(dist="binom",parm=list(size=1,prob=out.prob.CT[s2])))
marg.CC <- list(list(dist="binom",parm=list(size=1,prob=out.prob.CC)))
marg.EC <- list(list(dist="binom",parm=list(size=1,prob=out.prob.EC[s1])))
for(i in 1:ncov){
if(cov.CT[[i]]$dist=="norm"){
marg.CT <- append(marg.CT,list(list(dist=cov.CT[[i]]$dist,parm=list(mean=cov.CT[[i]]$mean,sd=cov.CT[[i]]$sd))))
marg.CC <- append(marg.CC,list(list(dist=cov.CC[[i]]$dist,parm=list(mean=cov.CC[[i]]$mean,sd=cov.CC[[i]]$sd))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(mean=cov.EC[[i]]$mean,sd=cov.EC[[i]]$sd))))
}else if(cov.CT[[i]]$dist=="binom"){
marg.CT <- append(marg.CT,list(list(dist=cov.CT[[i]]$dist,parm=list(size=1,prob=cov.CT[[i]]$prob))))
marg.CC <- append(marg.CC,list(list(dist=cov.CC[[i]]$dist,parm=list(size=1,prob=cov.CC[[i]]$prob))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(size=1,prob=cov.EC[[i]]$prob))))
}
}
cvec <- cormat[lower.tri(cormat)]
data.CT1 <- datagen(margdist=marg.CT,corvec=cvec,nsim=n.CT1)
data.CC1 <- datagen(margdist=marg.CC,corvec=cvec,nsim=n.CC1)
data.CT2 <- datagen(margdist=marg.CT,corvec=cvec,nsim=n.CT2)
data.CC2 <- datagen(margdist=marg.CC,corvec=cvec,nsim=n.CC2)
data.CT <- rbind(data.CT1,data.CT2)
data.CC <- rbind(data.CC1,data.CC2)
data.EC <- datagen(margdist=marg.EC,corvec=cvec,nsim=n.EC)
dat1 <- list(
nCT = n.CT1,
nCC = n.CC1,
p   = ncov,
yCT = data.CT1[,1],
yCC = data.CC1[,1],
xCT = data.CT1[,-1],
xCC = data.CC1[,-1])
dat2 <- list(
nEC = n.EC,
p   = ncov,
yEC = data.EC[,1],
xEC = data.EC[,-1],
a0  = a0)
dat3 <- list(
nCT = n.CT1,
nCC = n.CC1,
nEC = n.EC,
p   = ncov,
yCT = data.CT1[,1],
yCC = data.CC1[,1],
yEC = data.EC[,1],
xCT = data.CT1[,-1],
xCC = data.CC1[,-1],
xEC = data.EC[,-1],
a0  = a0)
dat4 <- list(
nCT = n.CT,
nCC = n.CC,
p   = ncov,
yCT = data.CT[,1],
yCC = data.CC[,1],
xCT = data.CT[,-1],
xCC = data.CC[,-1])
mcmc1 <- rstan::sampling(logistic.reg1,dat1,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc1.sample <- rstan::extract(mcmc1)
mcmc2 <- rstan::sampling(logistic.reg2,dat2,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc2.sample <- rstan::extract(mcmc2)
mcmc3 <- rstan::sampling(logistic.reg3,dat3,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc3.sample <- rstan::extract(mcmc3)
mcmc4 <- rstan::sampling(logistic.reg1,dat4,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc4.sample <- rstan::extract(mcmc4)
hat.gammaCC0 <- median(mcmc2.sample$gammaCC)
hat.beta0    <- apply(mcmc2.sample$beta,2,median)
hat.gammaCC1 <- median(mcmc1.sample$gammaCC)
hat.theta1   <- median(mcmc1.sample$theta)
hat.beta1    <- apply(mcmc1.sample$beta,2,median)
hat.gammaCC <- median(mcmc3.sample$gammaCC)
hat.theta   <- median(mcmc3.sample$theta)
hat.beta    <- apply(mcmc3.sample$beta,2,median)
m1.CT <- hat.gammaCC1+hat.theta1+(dat1$xCT)%*%hat.beta1
m1.CC <- hat.gammaCC1           +(dat1$xCC)%*%hat.beta1
m1    <- rbind(m1.CT,m1.CC)
m2    <- hat.gammaCC0           +(dat2$xEC)%*%hat.beta0
m3.CT <- hat.gammaCC +hat.theta +(dat1$xCT)%*%hat.beta
m3.CC <- hat.gammaCC            +(dat1$xCC)%*%hat.beta
m3    <- rbind(m3.CT,m3.CC)
m4    <- hat.gammaCC            +(dat2$xEC)%*%hat.beta
w[ss,s1,s2] <- (   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m1))))
+a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m2))))
-   sum(log(dbinom(c(dat1$yCT,dat1$yCC),1,boot::inv.logit(m3))))
-a0*sum(log(dbinom(dat2$yEC,            1,boot::inv.logit(m4)))))
if(alternative=="greater"){
p1[ss,s1,s2] <- mean(mcmc3.sample$theta>0)
p2[ss,s1,s2] <- mean(mcmc4.sample$theta>0)
}else if(alternative=="less"){
p1[ss,s1,s2] <- mean(mcmc3.sample$theta<0)
p2[ss,s1,s2] <- mean(mcmc4.sample$theta<0)
}
}}}
return(list(w=w,p1=p1,p2=p2))
}
cl <- makeCluster(ncore,type="SOCK")
library(snow)
install.packages(snow)
install.packages("snow")
library(snow)
cl <- makeCluster(ncore,type="SOCK")
clusterExport(cl,"simulation")
res.vec = clusterApply(cl,1:lsn,function(x){mysimulation()})
clusterExport(cl,"simulation")
res.vec = clusterApply(cl,1:ncore,function(x){simulation()})
nsim
library(iaborrow)
n.CT  <- 180
n.CC  <- 180
n.EC  <- 200
n.CT1 <- 90
n.CC1 <- 90
out.prob.CT <- c(0.23,0.35)
out.prob.CC <- 0.23
driftOR     <- c(0.6,1.0,1.4)
cov.CT <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cov.CC <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cov.EC <- list(list(dist="norm", mean=0,sd=1),
list(dist="binom",prob=0.2),
list(dist="binom",prob=0.4))
cormat <- rbind(c(1.0,0.1,0.2,0.3),
c(0.1,1.0,0.4,0.5),
c(0.2,0.4,1.0,0.6),
c(0.3,0.5,0.6,1.0))
a0 <- 0.5
w0 <- seq(0,5,0.1)
iaborrow.bin(
n.CT=n.CT, n.CC=n.CC, n.EC=n.EC, n.CT1=n.CT1, n.CC1=n.CC1,
out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
cov.CT=cov.CT, cov.CC=cov.CC, cov.EC=cov.EC, cormat=cormat,
a0=a0, w0=w0, ncore=2)
cov.CC
cov.CC
iaborrow.bin(
n.CT=n.CT, n.CC=n.CC, n.EC=n.EC, n.CT1=n.CT1, n.CC1=n.CC1,
out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
cov.CT=cov.CT, cov.CC=cov.CC, cov.EC=cov.EC, cormat=cormat,
a0=a0, w0=w0, ncore=2)
iaborrow.bin(
n.CT=n.CT, n.CC=n.CC, n.EC=n.EC, n.CT1=n.CT1, n.CC1=n.CC1,
out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
cov.CT=cov.CT, cov.CC=cov.CC, cov.EC=cov.EC, cormat=cormat,
a0=a0, w0=w0, ncore=2)
cov.CC
reject
reject
library(iaborrow)
library(iaborrow)
iaborrow.summary
library(iaborrow)
